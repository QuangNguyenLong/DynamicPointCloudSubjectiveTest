# Point Cloud Frame Rate Variation (FRV) Simulation

This Unity project is designed to simulate and test the perceptual impact of various frame rate instabilities on volumetric point cloud video streaming. It programmatically generates 42 distinct, deterministic patterns of frame rate variation over a 30 FPS source video.

The primary goal is to present these visual stimuli to a user and collect their feedback on the quality of the experience, which is saved to a Mean Opinion Score (MOS) log file.

## I. The Generation Mechanism: A Universal Stall-and-Skip Model

All variants are generated by a single, universal model that simulates how a client-side video player tries to keep up with an ideal "live" timeline. By modulating a single input—the target frames per second (FPS) for any given moment—this engine can produce any pattern of stalls (repeated frames) and skips (dropped frames).

The logic is implemented in the `BuildPlayedSequence` method in `FrameRateVariation.cs` and the `generate_schedule` function in the provided Python script. It operates on these key principles:

* **Ideal Timeline:** The simulation progresses through 300 display frames, representing 10 seconds of playback at 30 FPS. The `ideal_live_frame` represents the source frame that *should* be visible at any given moment if the stream were perfect.
* **Delivery Clock:** A float variable, `deliveryClock`, tracks the number of frames that *should have been delivered* by the source. This clock advances at the rate of the (potentially fluctuating) `target_fps`.
* **Last Shown Frame:** The system keeps track of the last frame number that was successfully displayed when a new frame was delivered.

On each display tick, the system makes a decision:

1.  It advances the `deliveryClock` based on the current `target_fps`.
2.  It checks if the integer value of the `deliveryClock` has increased since the last tick.
    * **Yes (A new frame has been "delivered"):** The player "catches up" to the timeline by displaying the current `ideal_live_frame`. This action creates a **skip** if the ideal frame has advanced more than one step since the last shown frame.
    * **No (No new frame was delivered):** The player is forced to repeat the `last_shown_frame`. This action creates a **stall**.

This elegant mechanism ensures that by simply defining a function for the `target_fps` over time, any complex pattern of instability can be reliably reproduced.

## II. The FRV Variants

The simulation includes several categories of variants designed to test different aspects of frame rate instability.

### 1. Baseline Variants
These variants provide a stable, constant frame rate to act as a control group for the study.
* **Description:** The video plays at a consistent FPS throughout the entire 10-second clip.
* **Implementations:** 30, 25, 20, and 15 FPS.

### 2. Single Macro-Drop Variants
These variants test the impact of a single, noticeable dip in quality in the middle of an otherwise stable stream.
* **Description:** The playback maintains a steady base FPS but drops to a lower "dip" FPS for a 30-frame window (from frame 135 to 164) before returning to the base rate.
* **Implementations:** Includes dips such as 30 to 15 FPS, 25 to 20 FPS, and others.

### 3. Micro-Stutter Variants
These variants simulate frequent, short stutters or hitches.
* **Description:** The frame rate repeatedly drops from a base FPS to a lower dip FPS for a very short duration (e.g., 1, 3, or 8 frames) at regular intervals (e.g., every 60 or 120 frames).
* **Implementations:** A wide grid of combinations, varying the base FPS, dip FPS, and the interval of the stutter events.

### 4. Jitter and Emergent Stall Variants
This group simulates more unpredictable or chaotic frame rate patterns.

* **Random Walk Jitter:**
    * **Description:** The frame rate fluctuates randomly around a target average. At fixed time intervals (`stepPeriod`), the FPS can increase, decrease, or stay the same by a small amount, but is clamped within a predefined range. This simulates a network connection with unstable but bounded bandwidth.
    * **Implementations:** Varies the target FPS, the random range (e.g., ±5 FPS), and the update period.

* **Hard Jitter (Frame Drops):**
    * **Description:** This simulates severe network issues by causing a certain percentage of frames to be dropped entirely. The generator randomly selects frames and sets their target FPS to 0, forcing a stall.
    * **Implementations:** Variants that drop 10% and 20% of the total frames.

## III. How to Run the Simulation

The project is controlled via the `FrameRateVariation.cs` script attached to a GameObject in a Unity scene.

1.  **Select a Variant:** In the Unity Inspector, set the `Variant Index` field (from 0 to 41) on the `DynamicPC` -> `{content_name}` component to choose the desired test pattern.
2.  **Configure Content:** Ensure the `Content Name` field matches the name of your point cloud data folder.
3.  **Run Scene:** Play the scene in the Unity Editor. The chosen variant will play automatically.
4.  **Provide Score:** After the sequence finishes, a UI will appear prompting for a MOS score from 1 to 5. Clicking a score button saves the result.
5.  **Output:** The results are saved to a text file in the `MOS_FRV` directory, named `MOS.user{id}.txt`. Each entry includes the variant index, the user's score, the clip duration, and the full comma-separated frame sequence that was played. The system then automatically proceeds to the next variant in the sequence.